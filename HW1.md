# [Содержание](README.md)

* **Домашнее задание 1**
    * **Задание**
        * [Блок 1](#part1)
            * [Задание 1 - Дни недели](#part1task1)
            * [Задание 2 - Натуральные числа](#part1task2)
            * [Задание 3 - Растительность](#part1task3)
        * [Блок 2 - Сворачиваемся](#part2)
            * [Задание 1 - Инстанс Foldable для Tree](#part2task1)
            * [Задание 2 - Разбиваемся](#part2task2)
        * [Блок 3 - Моноиды](#part3)
            * [Задание 1](#part3task1)
            * [Задание 2](#part3task2)
    * [**Реализация**](./src/Hw1)
        * [Блок 1](./src/Hw1/Part1)
            * [Задание 1 - Дни недели](./src/Hw1/Part1/Task1.hs)
            * [Задание 2 - Натуральные числа](./src/Hw1/Part1/Task2.hs)
            * [Задание 3 - Растительность](./src/Hw1/Part1/Task3.hs)
            * [**Тесты**](./test/Hw1/TestPart1)
        * [Блок 2 - Сворачиваемся](./src/Hw1/Part2)
            * [Задание 1 - Инстанс Foldable для Tree](./src/Hw1/Part2/Task1.hs)
            * [Задание 2 - Разбиваемся](./src/Hw1/Part2/Task2.hs)
            * [**Тесты**](./test/Hw1/TestPart2)
        * [Блок 3 - Моноиды](./src/Hw1/Part3)
            * [Задание 1](./src/Hw1/Part3/Task1.hs)
            * [Задание 2](./src/Hw1/Part3/Task2.hs)
            * [**Тесты**](./test/Hw1/TestPart3)

* [**Домашнее задание 2**](HW2.md)
* [**Домашнее задание 3**](HW3.md)
* [**Домашнее задание 4**](HW4.md)

---

# Haskell: ДЗ 1 -- Базовые конструкции языка и не только

Первое домашнее задание проверяет понимание базовых конструкций языка. А также стандартные функции и базовые интерфейсы.
Обратите внимание, что задание соответствует материалу, который рассказан в темах со 2 по
4ю [отсюда](https://github.com/jagajaga/FP-Course-ITMO).

В качестве вспомогательного материала про тестирование при выполнении этого ДЗ рекомендуется использовать
данные [слайды](https://slides.com/fp-ctd/lecture-55).

Некоторые задания имеют усложнённые версии, которые необходимо выполнять **дополнительно к базовой**, но они также будут
оценены дополнительными баллами.

В данном домашнем задании от Вас требуется познакомиться с некоторыми библиотеками для тестирования и реализовать тесты
с помощью них.

Тесты должны находиться в директории `test/`

Тесты должны запускаться командной `stack test`.

В заданиях явно указано, какие тесты для них должны быть реализованы.

## Блок 1:  Алгебраические типы данных <a id="part1"></a>

В этом блоке разрешено использовать автоматический `deriving` только для `Show`. Остальные инстансы необходимо
реализовывать самостоятельно.

### Задание 1: Дни недели <a id="part1task1"></a>

**Тесты:** Это задание необходимо протестировать при помощи простых unit-тестов.

Определите свой тип данных для _Дней недели_. Реализуйте следующие функции:

1. `nextDay`: возвращает следующий за переданным день недели.
2. `afterDays`: возвращает день недели, который наступит после заданного через переданное число дней.
3. `isWeekend`: проверяет, является ли день недели выходным.
4. `daysToParty`: выводит число дней, оставшихся до пятницы.

### Задание 2: Натуральные числа <a id="part1task2"></a>

**Тесты:** Это задание необходимо протестировать при помощи простых unit-тестов. Property-based тесты по желанию (
оцениваются дополнительными баллами).

#### Базовое задание

Этот тип данных для натуральных чисел определяется следующим образом:

```haskell
data Nat = Z | S Nat
```

Реализуйте следующие операции (которые должны быть реализованы полностью самостоятельно):

1. Сложение двух натуральных чисел.
2. Умножение двух натуральных чисел.
3. Вычитание натуральных чисел.
4. Превращение целых чисел в натуральные и наоборот.
5. Проверка натуральных чисел на равенство.
6. Сравнение натуральных чисел.

#### Усложнённая версия

Дополнительно требуется реализовать следующие функции:

7. Проверка натурального числа на чётность.
8. Целочисленное деление натуральных чисел.
9. Остаток от деления натурального числа на другое.

### Задание 3: Растительность <a id="part1task3"></a>

**Тесты:** Это задание необходимо протестировать при помощи простых unit-тестов.

Тип данных для двоичного дерева имеет два конструктора:

1. Лист дерева, не содержит данных.
2. Узел дерева. Содержит _непустой_ список одинаковых значений и имеет двух детей.

_Двоичное дерево_ называется _двоичным деревом поиска_ если оно удовлетворяет следующему условию: значения всех
элементов в левом поддереве меньше значения в узле, а значения элементов в правом поддереве больше значения в узле.

Реализуйте следующие операции с _двоичным деревом поиска_:

1. Проверка дерева на пустоту.
2. Подсчёт размера дерева (то есть числа элементов в нём).
3. Поиск заданного элемента в дереве (используйте тот факт, что дерево является деревом поиска).
4. Вставка нового элемента в _двоичное дерево поиска_. Если вставляемый элемент уже находится в дереве, то необходимо
   добавить его в список того узла, в котором этот элемент находится. Тут следует обратить внимание, что если в узле
   дерева есть список элементов, то этот список всегда непустой.
5. Функцию `fromList`, которая создаёт дерево из списка элементов.
6. Функцию, которая удаляет заданный элемент из дерева.

## Блок 2: Сворачиваемся <a id="part2"></a>

### Задание 1: Инстанс Foldable для Tree <a id="part2task1"></a>

**Тесты:** Это задание необходимо протестировать при помощи простых unit-тестов. Property-based тесты по желанию (
оцениваются дополнительными баллами).

В этом задании **обязательно** использовать расширение языка `-XInstanceSigs` и указывать типы функций в инстансах. При
этом необходимо реализовать обе функции `foldMap` и `foldr`.

Реализуйте инстанс `Foldable` для типа `Tree`. Инстанс должен быть реализован таким образом, чтобы выполнялось
свойство: `toList . fromList ≡ sort`.

### Задание 2: Разбиваемся <a id="part2task2"></a>

**Тесты:** Это задание необходимо протестировать при помощи простых unit-тестов. Property-based тесты по желанию (
оцениваются дополнительными баллами).

#### Базовая версия

Используя свёртку, реализуйте функцию `splitOn`, которая разбивает список на подсписки по элементу.

```haskell
ghci> splitOn '/' "path/to/file"
["path", "to", "file"]
```

Стоит обратить внимание, что функция `splitOn` всегда возвращает непустой список элементов. Это должно быть отражено в
типе. Пример приведён для обычного списка, хотя это решение не полностью корректное.

#### Усложнённая версия

Дополнительно реализуйте функцию (опять же, используя свёртку) `joinWith`, обратную `splitOn`. При этом Ваши реализации
должны удовлетворять свойству:

`joinWith x . splitOn x ≡ id`.

```haskell
ghci> joinWith '/' ["path", "to", "file"]
"path/to/file"
```

Стоит обратить внимание на то, что функция `joinWith` принимает непустой список.

## Блок 3: Моноиды <a id="part3"></a>

### Задание 1 <a id="part3task1"></a>

**Тесты:** Это задание необходимо протестировать при помощи простых unit-тестов.

#### Базовая версия

Напишите функцию, принимающую список списков внутри `Maybe` и возвращающую конкатенацию всех внутренних списков.

```haskell
ghci> maybeConcat [Just [1,2,3], Nothing, Just [4,5]]
[1,2,3,4,5]
```

#### Усложнённая версия

Функция должна принимать произвольный набор `Either`, где и `Left` и `Right` содержат некоторые моноидальные элементы, и
необходимо вернуть пару из результатов моноидального объединения отдельно элементов внутри `Left` и отдельно элементов
внутри `Right`.

```haskell
ghci> eitherConcat [Left (Sum 3), Right [1,2,3], Left (Sum 5), Right [4,5]]
(Sum {getSum = 8}, [1,2,3,4,5])
```

### Задание 2 <a id="part3task2"></a>

**Тесты:** Это задание необходимо протестировать при помощи простых unit-тестов.

#### Базовая версия

Реализуйте инстансы алгебраических классов типов для следующих структур данных. Ваши инстансы должны удовлетворять
законам для этих структур.

1. `Semigroup` для `data NonEmpty a = a :| [a]`.
2. `Semigroup` для типа данных `data ThisOrThat a b = This a | That b | Both a b`.

#### Усложнённая версия

Дополнительно реализуйте следующие инстансы:

1. `Semigroup` и `Monoid` для строк, объединяемых при помощи `'.'`.

```haskell
ghci> Name "root" <> Name "server"
Name "root.server"
```

2. `Semigroup` и `Monoid` для

```haskell
   newtype Endo a = Endo { getEndo :: a -> a }
```
